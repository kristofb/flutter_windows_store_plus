// Autogenerated from Pigeon (v26.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}
bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed
        .every(((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]));
  }
  if (a is Map && b is Map) {
    return a.length == b.length && a.entries.every((MapEntry<Object?, Object?> entry) =>
        (b as Map<Object?, Object?>).containsKey(entry.key) &&
        _deepEquals(entry.value, b[entry.key]));
  }
  return a == b;
}


/// Represents the kind of product available in the Microsoft Store.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeproduct.productkind?view=winrt-26100#windows-services-store-storeproduct-productkind
enum StoreProductKind {
  application,
  game,
  consumable,
  unmanagedConsumable,
  /// An add-on that persists for the lifetime that you specify in Partner Center.
  /// By default, durable add-ons never expire, in which case they can only be purchased once.
  /// If you specify a particular duration for the add-on, the user can repurchase the add-on after it expires.
  /// Note: A StoreProduct that represents a subscription add-on has the type Durable.
  durable,
}

/// Defines values that represent the units of a trial period or billing period for a subscription
enum StoreSubscriptionBillingPeriodUnit {
  minute,
  hour,
  day,
  week,
  month,
  year,
}

/// Gets valid license info for durables add-on that is associated with the current app
/// Invalid license are not included, licenses for consumable add-ons are not included.
class AddOnLicenseInner {
  AddOnLicenseInner({
    required this.inAppOfferToken,
    required this.skuStoreId,
    required this.expirationDate,
  });

  /// The product ID for the add-on.
  String inAppOfferToken;

  /// The Store ID of the licensed add-on SKU from the Microsoft Store catalog.
  String skuStoreId;

  /// Gets the expiration date and time for the add-on license. (ISO 8601)
  /// For durable lifetime add-ons, StoreLicense.ExpirationDate typically returns a value like 9999-12-31T00:00:00Z.
  /// This is not documented in Microsoft Learn, but has been confirmed through testing and community discussions (e.g., Stack Overflow, GitHub issues, MSDN forums).
  String expirationDate;

  List<Object?> _toList() {
    return <Object?>[
      inAppOfferToken,
      skuStoreId,
      expirationDate,
    ];
  }

  Object encode() {
    return _toList();  }

  static AddOnLicenseInner decode(Object result) {
    result as List<Object?>;
    return AddOnLicenseInner(
      inAppOfferToken: result[0]! as String,
      skuStoreId: result[1]! as String,
      expirationDate: result[2]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AddOnLicenseInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Provides license info for the current app, including licenses for products that are offered by the app.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeapplicense?view=winrt-26100
class StoreAppLicenseInner {
  StoreAppLicenseInner({
    required this.isActive,
    required this.isTrial,
    required this.skuStoreId,
    required this.trialUniqueId,
    required this.trialTimeRemaining,
    required this.expirationDate,
    required this.addOnLicenses,
  });

  /// Indicates whether the license is valid and provides the current user an entitlement to use the app.
  bool isActive;

  /// Indicates whether the license is a trial license.
  bool isTrial;

  /// Store ID of the licensed app SKU from the Microsoft Store catalog
  String skuStoreId;

  /// Unique ID that identifies the combination of the current user and the usage-limited trial that is associated with this app license
  /// (see trialTimeRemaining)
  String trialUniqueId;

  /// The remaining time for the usage-limited trial that is associated with this app license.
  /// This property is intended to be used by developers who have configured their app as a
  /// usage-limited trial in Partner Center.
  /// Usage-limited trials are currently available only to some developer accounts in Xbox managed partner programs.
  /// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeapplicense.trialtimeremaining?view=winrt-26100
  int trialTimeRemaining;

  /// Expiration date and time for the app license (ISO 8601)
  String expirationDate;

  /// Valid license info for durables add-on that is associated with the current app
  List<AddOnLicenseInner> addOnLicenses;

  List<Object?> _toList() {
    return <Object?>[
      isActive,
      isTrial,
      skuStoreId,
      trialUniqueId,
      trialTimeRemaining,
      expirationDate,
      addOnLicenses,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreAppLicenseInner decode(Object result) {
    result as List<Object?>;
    return StoreAppLicenseInner(
      isActive: result[0]! as bool,
      isTrial: result[1]! as bool,
      skuStoreId: result[2]! as String,
      trialUniqueId: result[3]! as String,
      trialTimeRemaining: result[4]! as int,
      expirationDate: result[5]! as String,
      addOnLicenses: (result[6] as List<Object?>?)!.cast<AddOnLicenseInner>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreAppLicenseInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Contains pricing info for a product listing in the Microsoft Store.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeprice?view=winrt-26100
class StorePriceInner {
  StorePriceInner({
    required this.currencyCode,
    required this.isOnSale,
    required this.saleEndDate,
    required this.formattedBasePrice,
    required this.formattedPrice,
    required this.formattedRecurrencePrice,
  });

  /// Gets the ISO 4217 currency code for the market of the current user.
  String currencyCode;

  /// Gets a value that indicates whether the product is on sale.
  bool isOnSale;

  /// Gets the end date for the sale period for the product, if the product is on sale. (ISO 8601)
  String saleEndDate;

  /// Gets the base price for the product with the appropriate formatting for the market of the current user.
  String formattedBasePrice;

  /// Gets the purchase price for the product with the appropriate formatting for the market of the current user.
  String formattedPrice;

  /// Gets the recurring price for the product with the appropriate formatting for the market of the current user, if recurring billing is enabled for this product.
  String formattedRecurrencePrice;

  List<Object?> _toList() {
    return <Object?>[
      currencyCode,
      isOnSale,
      saleEndDate,
      formattedBasePrice,
      formattedPrice,
      formattedRecurrencePrice,
    ];
  }

  Object encode() {
    return _toList();  }

  static StorePriceInner decode(Object result) {
    result as List<Object?>;
    return StorePriceInner(
      currencyCode: result[0]! as String,
      isOnSale: result[1]! as bool,
      saleEndDate: result[2]! as String,
      formattedBasePrice: result[3]! as String,
      formattedPrice: result[4]! as String,
      formattedRecurrencePrice: result[5]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StorePriceInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Provides subscription info for a product SKU that represents a subscription with recurring billing.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storesubscriptioninfo?view=winrt-26100
class StoreSubscriptionInfoInner {
  StoreSubscriptionInfoInner({
    required this.billingPeriod,
    required this.billingPeriodUnit,
    required this.hasTrialPeriod,
    required this.trialPeriod,
    required this.trialPeriodUnit,
  });

  /// Duration of the billing period for a subscription, in the units specified by the BillingPeriodUnit property.
  int billingPeriod;

  /// Units of the billing period for a subscription.
  StoreSubscriptionBillingPeriodUnit billingPeriodUnit;

  /// Value that indicates whether the subscription contains a trial period.
  bool hasTrialPeriod;

  /// Duration of the trial period for the subscription, in the units specified by the TrialPeriodUnit property. To determine whether the subscription has a trial period, use the HasTrialPeriod property.
  int trialPeriod;

  /// Units of the trial period for the subscription
  StoreSubscriptionBillingPeriodUnit trialPeriodUnit;

  List<Object?> _toList() {
    return <Object?>[
      billingPeriod,
      billingPeriodUnit,
      hasTrialPeriod,
      trialPeriod,
      trialPeriodUnit,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreSubscriptionInfoInner decode(Object result) {
    result as List<Object?>;
    return StoreSubscriptionInfoInner(
      billingPeriod: result[0]! as int,
      billingPeriodUnit: result[1]! as StoreSubscriptionBillingPeriodUnit,
      hasTrialPeriod: result[2]! as bool,
      trialPeriod: result[3]! as int,
      trialPeriodUnit: result[4]! as StoreSubscriptionBillingPeriodUnit,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreSubscriptionInfoInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Provides additional data for a product SKU that the user has an entitlement to use.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storecollectiondata?view=winrt-26100
class StoreCollectionDataInner {
  StoreCollectionDataInner({
    required this.campaignId,
    required this.developerOfferId,
    required this.extendedJsonData,
    required this.isTrial,
    required this.acquiredDate,
    required this.startDate,
    required this.endDate,
    required this.trialTimeRemaining,
  });

  /// Promotion campaign ID that is associated with the product SKU.
  String campaignId;

  /// Developer offer ID that is associated with the product SKU.
  String developerOfferId;

  /// Complete collection data for the product SKU in JSON format.
  String extendedJsonData;

  /// Value that indicates whether the product SKU is a trial version.
  bool isTrial;

  /// Date on which the product SKU was acquired.
  String acquiredDate;

  /// Start date of the trial for the product SKU, if the SKU is a trial version or a durable add-on that expires after a set duration.
  String startDate;

  /// The end date of the trial for the product SKU, if the SKU is a trial version or a durable add-on that expires after a set duration.
  String endDate;

  /// Remaining trial time for the usage-limited trial that is associated with this product SKU. (in seconds)
  int trialTimeRemaining;

  List<Object?> _toList() {
    return <Object?>[
      campaignId,
      developerOfferId,
      extendedJsonData,
      isTrial,
      acquiredDate,
      startDate,
      endDate,
      trialTimeRemaining,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreCollectionDataInner decode(Object result) {
    result as List<Object?>;
    return StoreCollectionDataInner(
      campaignId: result[0]! as String,
      developerOfferId: result[1]! as String,
      extendedJsonData: result[2]! as String,
      isTrial: result[3]! as bool,
      acquiredDate: result[4]! as String,
      startDate: result[5]! as String,
      endDate: result[6]! as String,
      trialTimeRemaining: result[7]! as int,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreCollectionDataInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Provides info for a stock keeping unit (SKU) of a product in the Microsoft Store
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storesku?view=winrt-26100
class StoreProductSkuInner {
  StoreProductSkuInner({
    required this.storeId,
    required this.isTrial,
    required this.isSubscription,
    required this.description,
    required this.title,
    this.subscriptionInfo,
    required this.price,
    required this.customDeveloperData,
    required this.extendedJsonData,
    required this.isInUserCollection,
    required this.collectionData,
  });

  /// Store ID of this product SKU
  String storeId;

  /// Indicates whether this product SKU is a trial SKU
  bool isTrial;

  /// Indicates whether this product SKU is a subscription SKU
  bool isSubscription;

  /// Product SKU description from the Microsoft Store listing.
  String description;

  /// Product SKU title from the Microsoft Store listing.
  String title;

  /// Subscription information for this product SKU, if this product SKU is a subscription with recurring billing.
  /// To determine whether this product SKU is a subscription, use the IsSubscription property.
  StoreSubscriptionInfoInner? subscriptionInfo;

  /// Price of the default availability for this product SKU.
  StorePriceInner price;

  /// The custom developer data string (also called a tag) that contains custom information about
  /// the add-on that this product SKU represents.
  /// This string corresponds to the value of the Custom developer data field in the properties page for the add-on in Partner Center.
  String customDeveloperData;

  /// Complete data for the current product SKU from the Store in JSON format.
  String extendedJsonData;

  /// Value that indicates whether the current user has an entitlement to use the current product SKU.
  bool isInUserCollection;

  /// Additional data for the current product SKU, if the user has an entitlement to use the SKU.
  /// Valid only if isInUserCollection is true.
  StoreCollectionDataInner collectionData;

  List<Object?> _toList() {
    return <Object?>[
      storeId,
      isTrial,
      isSubscription,
      description,
      title,
      subscriptionInfo,
      price,
      customDeveloperData,
      extendedJsonData,
      isInUserCollection,
      collectionData,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreProductSkuInner decode(Object result) {
    result as List<Object?>;
    return StoreProductSkuInner(
      storeId: result[0]! as String,
      isTrial: result[1]! as bool,
      isSubscription: result[2]! as bool,
      description: result[3]! as String,
      title: result[4]! as String,
      subscriptionInfo: result[5] as StoreSubscriptionInfoInner?,
      price: result[6]! as StorePriceInner,
      customDeveloperData: result[7]! as String,
      extendedJsonData: result[8]! as String,
      isInUserCollection: result[9]! as bool,
      collectionData: result[10]! as StoreCollectionDataInner,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreProductSkuInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Add-on associated to the application in the Microsoft Store
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeproduct?view=winrt-26100
class StoreProductInner {
  StoreProductInner({
    required this.storeId,
    required this.description,
    required this.title,
    required this.inAppOfferToken,
    required this.productKind,
    required this.price,
    required this.skus,
  });

  /// Gets the Store ID for this product. For an add-on, this property corresponds to the Store ID that is available on the overview page for the add-on.
  String storeId;

  /// Gets the product description from the Microsoft Store listing.
  String description;

  /// Gets the product title from the Microsoft Store listing.
  String title;

  /// Gets the product ID for this product, if the current StoreProduct represents an add-on.
  String inAppOfferToken;

  /// Gets the type of the product.
  StoreProductKind productKind;

  /// Gets the price for the default SKU and availability for the product.
  StorePriceInner price;

  /// List of available SKUs for the product.
  List<StoreProductSkuInner> skus;

  List<Object?> _toList() {
    return <Object?>[
      storeId,
      description,
      title,
      inAppOfferToken,
      productKind,
      price,
      skus,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreProductInner decode(Object result) {
    result as List<Object?>;
    return StoreProductInner(
      storeId: result[0]! as String,
      description: result[1]! as String,
      title: result[2]! as String,
      inAppOfferToken: result[3]! as String,
      productKind: result[4]! as StoreProductKind,
      price: result[5]! as StorePriceInner,
      skus: (result[6] as List<Object?>?)!.cast<StoreProductSkuInner>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreProductInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

class AssociatedStoreProductsInner {
  AssociatedStoreProductsInner({
    required this.products,
  });

  List<StoreProductInner> products;

  List<Object?> _toList() {
    return <Object?>[
      products,
    ];
  }

  Object encode() {
    return _toList();  }

  static AssociatedStoreProductsInner decode(Object result) {
    result as List<Object?>;
    return AssociatedStoreProductsInner(
      products: (result[0] as List<Object?>?)!.cast<StoreProductInner>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AssociatedStoreProductsInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is StoreProductKind) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is StoreSubscriptionBillingPeriodUnit) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    }    else if (value is AddOnLicenseInner) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    }    else if (value is StoreAppLicenseInner) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    }    else if (value is StorePriceInner) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    }    else if (value is StoreSubscriptionInfoInner) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    }    else if (value is StoreCollectionDataInner) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    }    else if (value is StoreProductSkuInner) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    }    else if (value is StoreProductInner) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    }    else if (value is AssociatedStoreProductsInner) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StoreProductKind.values[value];
      case 130: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StoreSubscriptionBillingPeriodUnit.values[value];
      case 131: 
        return AddOnLicenseInner.decode(readValue(buffer)!);
      case 132: 
        return StoreAppLicenseInner.decode(readValue(buffer)!);
      case 133: 
        return StorePriceInner.decode(readValue(buffer)!);
      case 134: 
        return StoreSubscriptionInfoInner.decode(readValue(buffer)!);
      case 135: 
        return StoreCollectionDataInner.decode(readValue(buffer)!);
      case 136: 
        return StoreProductSkuInner.decode(readValue(buffer)!);
      case 137: 
        return StoreProductInner.decode(readValue(buffer)!);
      case 138: 
        return AssociatedStoreProductsInner.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// If you're building a storefront:
/// - Use getAppLicenseAsync to show the user's app license info and add-ons purchased
/// - Use getAssociatedStoreProductsAsync to show what’s available for purchase
/// - Use getUserCollectionAsync to show what the user already owns, even if it’s no longer purchasable
class WindowsStoreApi {
  /// Constructor for [WindowsStoreApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  WindowsStoreApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<StoreAppLicenseInner> getAppLicenseAsync() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.windows_store.WindowsStoreApi.getAppLicenseAsync$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StoreAppLicenseInner?)!;
    }
  }

  /// Gets Microsoft Store listing info for the products that can be purchased from within the current app.
  /// productKind: The kind of product to retrieve.
  /// collectionData attribute of store product SKU CANNOT be used.
  /// Reflects the current store state with add-ons available.
  /// 
  /// This method returns StoreProduct objects for add-ons that are:
  /// - Currently associated with your app
  /// - Available for sale in the Microsoft Store
  /// - Filtered by product kind (e.g., "Durable", "Subscription")
  ///
  /// Key traits:
  /// - Focuses on catalog visibility
  /// - Only includes active, sellable products
  /// - Does not include user-specific data like ownership or acquisition
  Future<AssociatedStoreProductsInner> getAssociatedStoreProductsAsync(StoreProductKind productKind) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.windows_store.WindowsStoreApi.getAssociatedStoreProductsAsync$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[productKind]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as AssociatedStoreProductsInner?)!;
    }
  }

  /// Gets Microsoft Store info for the add-ons of the current app for which the user has purchased.
  /// Returns a StoreProductQueryResult object that contains Microsoft Store info for the add-ons of the current app for which the user has purchased and relevant error info.
  /// productKind: The kind of product to retrieve.
  /// collectionData attribute of store product SKU can be used.
  /// 
  /// This method returns StoreProduct objects that the user has acquired, regardless of whether they’re still available for sale.
  ///
  /// Key traits:
  /// - Focuses on user entitlements
  /// - Includes products the user owns, even if they’re no longer listed or sold
  /// - Populates StoreSku.CollectionData with user-specific info (e.g., AcquiredDate, IsTrial, ExtendedJsonData)
  /// - May include outdated, deprecated, or hidden add-ons
  Future<AssociatedStoreProductsInner> getUserCollectionAsync(StoreProductKind productKind) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.windows_store.WindowsStoreApi.getUserCollectionAsync$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[productKind]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as AssociatedStoreProductsInner?)!;
    }
  }
}

// Autogenerated from Pigeon (v26.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}
bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed
        .every(((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]));
  }
  if (a is Map && b is Map) {
    return a.length == b.length && a.entries.every((MapEntry<Object?, Object?> entry) =>
        (b as Map<Object?, Object?>).containsKey(entry.key) &&
        _deepEquals(entry.value, b[entry.key]));
  }
  return a == b;
}


/// Represents the kind of product available in the Microsoft Store.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeproduct.productkind?view=winrt-26100#windows-services-store-storeproduct-productkind
enum StoreProductKind {
  application,
  game,
  consumable,
  unmanagedConsumable,
  /// An add-on that persists for the lifetime that you specify in Partner Center.
  /// By default, durable add-ons never expire, in which case they can only be purchased once.
  /// If you specify a particular duration for the add-on, the user can repurchase the add-on after it expires.
  /// Note: A StoreProduct that represents a subscription add-on has the type Durable.
  durable,
}

/// Gets valid license info for durables add-on that is associated with the current app
/// Invalid license are not included, licenses for consumable add-ons are not included.
class AddOnLicenseInner {
  AddOnLicenseInner({
    required this.inAppOfferToken,
    required this.skuStoreId,
    required this.expirationDate,
  });

  /// The product ID for the add-on.
  String inAppOfferToken;

  /// The Store ID of the licensed add-on SKU from the Microsoft Store catalog.
  String skuStoreId;

  /// Gets the expiration date and time for the add-on license. (ISO 8601)
  String expirationDate;

  List<Object?> _toList() {
    return <Object?>[
      inAppOfferToken,
      skuStoreId,
      expirationDate,
    ];
  }

  Object encode() {
    return _toList();  }

  static AddOnLicenseInner decode(Object result) {
    result as List<Object?>;
    return AddOnLicenseInner(
      inAppOfferToken: result[0]! as String,
      skuStoreId: result[1]! as String,
      expirationDate: result[2]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AddOnLicenseInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Provides license info for the current app, including licenses for products that are offered by the app.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeapplicense?view=winrt-26100
class StoreAppLicenseInner {
  StoreAppLicenseInner({
    required this.isActive,
    required this.isTrial,
    required this.skuStoreId,
    required this.trialUniqueId,
    required this.trialTimeRemaining,
    required this.expirationDate,
    required this.addOnLicenses,
  });

  /// Indicates whether the license is valid and provides the current user an entitlement to use the app.
  bool isActive;

  /// Indicates whether the license is a trial license.
  bool isTrial;

  /// Store ID of the licensed app SKU from the Microsoft Store catalog
  String skuStoreId;

  /// Unique ID that identifies the combination of the current user and the usage-limited trial that is associated with this app license
  String trialUniqueId;

  /// Remaining time for the usage-limited trial that is associated with this app license
  int trialTimeRemaining;

  /// Expiration date and time for the app license (ISO 8601)
  String expirationDate;

  /// Valid license info for durables add-on that is associated with the current app
  List<AddOnLicenseInner> addOnLicenses;

  List<Object?> _toList() {
    return <Object?>[
      isActive,
      isTrial,
      skuStoreId,
      trialUniqueId,
      trialTimeRemaining,
      expirationDate,
      addOnLicenses,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreAppLicenseInner decode(Object result) {
    result as List<Object?>;
    return StoreAppLicenseInner(
      isActive: result[0]! as bool,
      isTrial: result[1]! as bool,
      skuStoreId: result[2]! as String,
      trialUniqueId: result[3]! as String,
      trialTimeRemaining: result[4]! as int,
      expirationDate: result[5]! as String,
      addOnLicenses: (result[6] as List<Object?>?)!.cast<AddOnLicenseInner>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreAppLicenseInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Contains pricing info for a product listing in the Microsoft Store.
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeprice?view=winrt-26100
class StorePriceInner {
  StorePriceInner({
    required this.currencyCode,
    required this.isOnSale,
    required this.saleEndDate,
    required this.formattedBasePrice,
    required this.formattedPrice,
    required this.formattedRecurrencePrice,
  });

  /// Gets the ISO 4217 currency code for the market of the current user.
  String currencyCode;

  /// Gets a value that indicates whether the product is on sale.
  bool isOnSale;

  /// Gets the end date for the sale period for the product, if the product is on sale. (ISO 8601)
  String saleEndDate;

  /// Gets the base price for the product with the appropriate formatting for the market of the current user.
  String formattedBasePrice;

  /// Gets the purchase price for the product with the appropriate formatting for the market of the current user.
  String formattedPrice;

  /// Gets the recurring price for the product with the appropriate formatting for the market of the current user, if recurring billing is enabled for this product.
  String formattedRecurrencePrice;

  List<Object?> _toList() {
    return <Object?>[
      currencyCode,
      isOnSale,
      saleEndDate,
      formattedBasePrice,
      formattedPrice,
      formattedRecurrencePrice,
    ];
  }

  Object encode() {
    return _toList();  }

  static StorePriceInner decode(Object result) {
    result as List<Object?>;
    return StorePriceInner(
      currencyCode: result[0]! as String,
      isOnSale: result[1]! as bool,
      saleEndDate: result[2]! as String,
      formattedBasePrice: result[3]! as String,
      formattedPrice: result[4]! as String,
      formattedRecurrencePrice: result[5]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StorePriceInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

/// Add-on associated to the application in the Microsoft Store
/// https://learn.microsoft.com/en-us/uwp/api/windows.services.store.storeproduct?view=winrt-26100
class StoreProductInner {
  StoreProductInner({
    required this.storeId,
    required this.description,
    required this.title,
    required this.inAppOfferToken,
    required this.productKind,
    required this.price,
  });

  /// Gets the Store ID for this product. For an add-on, this property corresponds to the Store ID that is available on the overview page for the add-on.
  String storeId;

  /// Gets the product description from the Microsoft Store listing.
  String description;

  /// Gets the product title from the Microsoft Store listing.
  String title;

  /// Gets the product ID for this product, if the current StoreProduct represents an add-on.
  String inAppOfferToken;

  /// Gets the type of the product.
  StoreProductKind productKind;

  /// Gets the price for the default SKU and availability for the product.
  StorePriceInner price;

  List<Object?> _toList() {
    return <Object?>[
      storeId,
      description,
      title,
      inAppOfferToken,
      productKind,
      price,
    ];
  }

  Object encode() {
    return _toList();  }

  static StoreProductInner decode(Object result) {
    result as List<Object?>;
    return StoreProductInner(
      storeId: result[0]! as String,
      description: result[1]! as String,
      title: result[2]! as String,
      inAppOfferToken: result[3]! as String,
      productKind: result[4]! as StoreProductKind,
      price: result[5]! as StorePriceInner,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! StoreProductInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

class AssociatedStoreProductsInner {
  AssociatedStoreProductsInner({
    required this.products,
  });

  List<StoreProductInner> products;

  List<Object?> _toList() {
    return <Object?>[
      products,
    ];
  }

  Object encode() {
    return _toList();  }

  static AssociatedStoreProductsInner decode(Object result) {
    result as List<Object?>;
    return AssociatedStoreProductsInner(
      products: (result[0] as List<Object?>?)!.cast<StoreProductInner>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AssociatedStoreProductsInner || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is StoreProductKind) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is AddOnLicenseInner) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    }    else if (value is StoreAppLicenseInner) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    }    else if (value is StorePriceInner) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    }    else if (value is StoreProductInner) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    }    else if (value is AssociatedStoreProductsInner) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StoreProductKind.values[value];
      case 130: 
        return AddOnLicenseInner.decode(readValue(buffer)!);
      case 131: 
        return StoreAppLicenseInner.decode(readValue(buffer)!);
      case 132: 
        return StorePriceInner.decode(readValue(buffer)!);
      case 133: 
        return StoreProductInner.decode(readValue(buffer)!);
      case 134: 
        return AssociatedStoreProductsInner.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class WindowsStoreApi {
  /// Constructor for [WindowsStoreApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  WindowsStoreApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<StoreAppLicenseInner> getAppLicenseAsync() async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.windows_store.WindowsStoreApi.getAppLicenseAsync$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StoreAppLicenseInner?)!;
    }
  }

  /// Gets Microsoft Store listing info for the products that can be purchased from within the current app.
  /// productKind: The kind of product to retrieve.
  Future<AssociatedStoreProductsInner> getAssociatedStoreProductsAsync(StoreProductKind productKind) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.windows_store.WindowsStoreApi.getAssociatedStoreProductsAsync$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(<Object?>[productKind]);
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as AssociatedStoreProductsInner?)!;
    }
  }
}
